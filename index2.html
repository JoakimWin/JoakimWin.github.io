<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>JW</title>
		<style>
			body { margin: 0; }
		</style>
	</head>
	<body>
		
        <script type="module">

            import * as THREE from '/js/three.module.js';
            import { GLTFLoader } from '/js/GLTFLoader.js';
            import { OrbitControls } from '/js/OrbitControls.js';

            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

            const renderer = new THREE.WebGLRenderer( { antialias: true } );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
            document.body.appendChild( renderer.domElement );

            // const geometry = new THREE.BoxGeometry();
            // const material = new THREE.MeshBasicMaterial( { color: 0x808080 } );
            // const cube = new THREE.Mesh( geometry, material );
            // scene.add( cube );
            // cube.position.x = 3;

            camera.position.z = 40;
                        

            // probe
			const lightProbe = new THREE.LightProbe();
			scene.add( lightProbe );

            // light
			const API = {
				lightProbeIntensity: 2.0,
				directionalLightIntensity: 2.2,
				envMapIntensity: 1
			};

            const directionalLight = new THREE.DirectionalLight( 0xffffff, API.directionalLightIntensity );
            directionalLight.position.set( 0, 0, 5 );
            scene.add( directionalLight );

            let model;
            const loader = new GLTFLoader();
            //loader.load( '/assets/scifi_girl_v.01/scene.gltf', function ( gltf ) {
            loader.load( '/assets/abstract_sphere/scene.gltf', function ( gltf ) {
                model = gltf.scene;
                model.position.set(0,-1,0);
                //model.rotation.y = -1.57;
                model.scale.set( 1, 1, 1 );
                scene.add( model );
                }, undefined, function ( error ) {
                    console.error( error );
                } );


            // const linematerial = new THREE.LineBasicMaterial( { color: 0x0000ff } );
            // const points = [];
            // points.push( new THREE.Vector3( - 1, 0, 0 ) );
            // points.push( new THREE.Vector3( 0, 1, 0 ) );
            // points.push( new THREE.Vector3( 1, 0, 0 ) );
            // const linegeometry = new THREE.BufferGeometry().setFromPoints( points );
            // const line = new THREE.Line( linegeometry, linematerial );
            //scene.add( line );

            // controls
            const controls = new OrbitControls( camera, renderer.domElement );
            controls.addEventListener( 'change', render );
            controls.minDistance = 5;
            controls.maxDistance = 50;
            controls.enablePan = false;

            let xd = 0.1;
            let yd = 0.1;
            let zd = 0.1;
            let x, y, z;
            
            const animate = function () {
                requestAnimationFrame( animate );

                model.rotation.x += 0.01;
                model.rotation.y += 0.01;

                x = model.position.x + xd;
                y = model.position.y + yd;
                z = model.position.z + zd;

                console.log('x: ' + x);
                console.log('y: ' + y);

                if( x > camera.getFilmWidth()/2 ){
                    xd *= -1;
                }

                if( x < -camera.getFilmWidth()/2 ){
                    xd *= -1;
                }

                if( y > camera.getFilmHeight()/2 ){
                    yd *= -1;
                }

                if( y < -camera.getFilmHeight()/2 ){
                    yd *= -1;
                }

                if( z > 0 ){
                    zd *= -1;
                }

                if( z < -100 ){
                    zd *= -1;
                }

                model.position.x = x;
                model.position.y = y;
                model.position.z = z;

                renderer.render( scene, camera );
            };

            // listener
			window.addEventListener( 'resize', onWindowResize );

            animate();

            function onWindowResize() {
                renderer.setSize( window.innerWidth, window.innerHeight );
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                render();
            }

            function render() {
                renderer.render( scene, camera );
            }

		</script>

	</body>
</html>